# 后端实现规范

> 配合主需求文档使用

## 1. 项目结构

```
mora-backend/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI应用入口
│   ├── config.py               # 配置管理
│   ├── database.py             # 数据库连接
│   ├── dependencies.py         # 依赖注入
│   │
│   ├── models/                 # SQLAlchemy模型
│   │   ├── __init__.py
│   │   └── session.py
│   │
│   ├── schemas/                # Pydantic schemas
│   │   ├── __init__.py
│   │   ├── session.py
│   │   └── timeline.py
│   │
│   ├── api/                    # API路由
│   │   ├── __init__.py
│   │   ├── session.py          # 会话管理API
│   │   └── stream.py           # SSE流式推送
│   │
│   ├── services/               # 业务逻辑
│   │   ├── __init__.py
│   │   ├── video_processor.py  # 视频URL验证
│   │   ├── bibigpt_service.py  # BibiGPT集成
│   │   ├── deepseek_service.py # DeepSeek集成
│   │   └── timeline_service.py # 时间轴生成
│   │
│   └── utils/                  # 工具函数
│       ├── __init__.py
│       ├── sse.py              # SSE工具
│       ├── cache.py            # Redis缓存
│       └── errors.py           # 错误定义
│
├── alembic/                    # 数据库迁移
│   ├── versions/
│   │   └── 001_create_sessions.py
│   ├── env.py
│   └── script.py.mako
│
├── tests/                      # 测试
│   ├── __init__.py
│   ├── test_api.py
│   ├── test_services.py
│   └── conftest.py
│
├── .env.example                # 环境变量模板
├── .gitignore
├── alembic.ini                 # Alembic配置
├── requirements.txt            # Python依赖
├── docker-compose.yml          # Docker配置
├── Dockerfile
└── README.md
```

## 2. 依赖安装

### 2.1 requirements.txt

```txt
# Web框架
fastapi==0.108.0
uvicorn[standard]==0.25.0

# 数据库
sqlalchemy==2.0.23
alembic==1.13.1
psycopg2-binary==2.9.9

# 缓存
redis==5.0.1

# 数据验证
pydantic==2.5.3
pydantic-settings==2.1.0

# HTTP客户端
httpx==0.26.0

# 工具
python-dotenv==1.0.0
python-multipart==0.0.6

# 开发工具
pytest==7.4.3
pytest-asyncio==0.21.1
black==23.12.1
ruff==0.1.9
```

### 2.2 安装命令

```bash
# 创建虚拟环境
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate  # Windows

# 安装依赖
pip install -r requirements.txt
```

## 3. 配置管理

### 3.1 config.py

```python
# app/config.py
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    """应用配置"""
    
    # 应用基础配置
    APP_NAME: str = "Mora Backend"
    DEBUG: bool = False
    VERSION: str = "1.0.0"
    
    # 数据库配置
    DATABASE_URL: str
    
    # Redis配置
    REDIS_URL: str = "redis://localhost:6379/0"
    
    # BibiGPT API配置
    BIBIGPT_API_KEY: str
    BIBIGPT_API_URL: str = "https://api.bibigpt.co/api/v1"
    BIBIGPT_TIMEOUT: int = 60  # 秒
    
    # DeepSeek API配置
    DEEPSEEK_API_KEY: str
    DEEPSEEK_API_URL: str = "https://api.deepseek.com/v1"
    DEEPSEEK_MODEL: str = "deepseek-coder"
    DEEPSEEK_TIMEOUT: int = 120  # 秒
    DEEPSEEK_TEMPERATURE: float = 0.3
    
    # 功能配置
    ENABLE_CACHE: bool = True
    CACHE_TTL: int = 3600  # 1小时
    VIDEO_CACHE_TTL: int = 86400  # 24小时
    MAX_VIDEO_DURATION: int = 7200  # 2小时
    
    # 限流配置
    MAX_REQUESTS_PER_MINUTE: int = 10
    
    # CORS配置
    CORS_ORIGINS: list[str] = [
        "http://localhost:5173",
        "http://localhost:3000",
    ]
    
    class Config:
        env_file = ".env"
        case_sensitive = True

@lru_cache()
def get_settings() -> Settings:
    """获取配置单例"""
    return Settings()
```

### 3.2 .env.example

```bash
# 应用配置
APP_NAME=Mora Backend
DEBUG=False
VERSION=1.0.0

# 数据库
DATABASE_URL=postgresql://mora:password@localhost:5432/mora

# Redis
REDIS_URL=redis://localhost:6379/0

# BibiGPT API
BIBIGPT_API_KEY=your_bibigpt_api_key_here
BIBIGPT_API_URL=https://api.bibigpt.co/api/v1
BIBIGPT_TIMEOUT=60

# DeepSeek API
DEEPSEEK_API_KEY=your_deepseek_api_key_here
DEEPSEEK_API_URL=https://api.deepseek.com/v1
DEEPSEEK_MODEL=deepseek-coder
DEEPSEEK_TIMEOUT=120
DEEPSEEK_TEMPERATURE=0.3

# 功能配置
ENABLE_CACHE=true
CACHE_TTL=3600
VIDEO_CACHE_TTL=86400
MAX_VIDEO_DURATION=7200

# 限流
MAX_REQUESTS_PER_MINUTE=10

# CORS（开发环境）
CORS_ORIGINS=["http://localhost:5173","http://localhost:3000"]
```

## 4. 数据库配置

### 4.1 database.py

```python
# app/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.config import get_settings

settings = get_settings()

# 创建数据库引擎
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,      # 连接前测试
    pool_size=10,            # 连接池大小
    max_overflow=20,         # 最大溢出连接数
    echo=settings.DEBUG,     # 开发环境打印SQL
)

# 创建会话工厂
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# 声明基类
Base = declarative_base()

def get_db():
    """数据库依赖注入"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### 4.2 models/session.py

```python
# app/models/session.py
from sqlalchemy import Column, String, Text, DateTime, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID, JSONB
from app.database import Base
import uuid
from datetime import datetime
import enum

class SessionStatus(str, enum.Enum):
    """会话状态枚举"""
    CREATED = "created"
    PROCESSING = "processing"
    COMPLETED = "completed"
    ERROR = "error"

class Session(Base):
    """会话模型"""
    __tablename__ = "sessions"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    video_url = Column(Text, nullable=False, index=True)
    language = Column(String(20), default="python")
    status = Column(
        SQLEnum(SessionStatus), 
        nullable=False, 
        default=SessionStatus.CREATED,
        index=True
    )
    
    # JSON字段
    video_info = Column(JSONB, nullable=True)
    subtitles = Column(JSONB, nullable=True)
    timeline = Column(JSONB, nullable=True)
    
    # 文本字段
    generated_code = Column(Text, nullable=True)
    error_message = Column(Text, nullable=True)
    
    # 时间戳
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<Session {self.id} - {self.status}>"
```

### 4.3 schemas/session.py

```python
# app/schemas/session.py
from pydantic import BaseModel, HttpUrl, Field
from typing import Optional, Dict, Any
from datetime import datetime
from enum import Enum

class SessionStatus(str, Enum):
    """会话状态"""
    created = "created"
    processing = "processing"
    completed = "completed"
    error = "error"

class CreateSessionRequest(BaseModel):
    """创建会话请求"""
    videoUrl: HttpUrl = Field(..., description="视频URL")
    language: Optional[str] = Field("python", description="编程语言")

class SessionResponse(BaseModel):
    """会话响应（简化版）"""
    sessionId: str
    videoUrl: str
    status: SessionStatus
    createdAt: datetime

class VideoInfo(BaseModel):
    """视频信息"""
    title: str
    duration: int
    thumbnail: str
    author: Optional[str] = None

class SessionDetailResponse(BaseModel):
    """会话详细响应"""
    sessionId: str
    videoUrl: str
    status: SessionStatus
    videoInfo: Optional[VideoInfo] = None
    generatedCode: Optional[str] = None
    timeline: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    createdAt: datetime
    updatedAt: datetime
    
    class Config:
        from_attributes = True  # Pydantic v2
```

## 5. Redis缓存

```python
# app/utils/cache.py
import redis
import json
from typing import Optional, Any
from app.config import get_settings

settings = get_settings()

# 创建Redis客户端
redis_client = redis.from_url(
    settings.REDIS_URL,
    decode_responses=True,
    socket_connect_timeout=5,
    socket_keepalive=True
)

class Cache:
    """Redis缓存工具类"""
    
    @staticmethod
    def get(key: str) -> Optional[Any]:
        """获取缓存"""
        try:
            value = redis_client.get(key)
            if value:
                return json.loads(value)
            return None
        except Exception as e:
            print(f"Cache get error for key {key}: {e}")
            return None
    
    @staticmethod
    def set(key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """设置缓存"""
        try:
            ttl = ttl or settings.CACHE_TTL
            serialized = json.dumps(value, ensure_ascii=False)
            redis_client.setex(key, ttl, serialized)
            return True
        except Exception as e:
            print(f"Cache set error for key {key}: {e}")
            return False
    
    @staticmethod
    def delete(key: str) -> bool:
        """删除缓存"""
        try:
            redis_client.delete(key)
            return True
        except Exception as e:
            print(f"Cache delete error for key {key}: {e}")
            return False
    
    @staticmethod
    def exists(key: str) -> bool:
        """检查key是否存在"""
        try:
            return redis_client.exists(key) > 0
        except Exception as e:
            print(f"Cache exists error for key {key}: {e}")
            return False

# 缓存key生成器
class CacheKeys:
    """缓存key命名规范"""
    
    @staticmethod
    def video_subtitle(video_url: str) -> str:
        """视频字幕缓存key"""
        return f"video:{video_url}:subtitle"
    
    @staticmethod
    def session_result(session_id: str) -> str:
        """会话结果缓存key"""
        return f"session:{session_id}:result"
```

## 6. 业务服务实现

### 6.1 video_processor.py

```python
# app/services/video_processor.py
import re
from typing import Optional

class VideoProcessor:
    """视频处理器"""
    
    # 支持的平台正则表达式
    YOUTUBE_REGEX = r'^(https?://)?(www\.)?(youtube\.com|youtu\.be)/.+'
    BILIBILI_REGEX = r'^(https?://)?(www\.)?bilibili\.com/(video|bangumi)/.+'
    TIKTOK_REGEX = r'^(https?://)?(www\.)?(tiktok\.com|vm\.tiktok\.com)/.+'
    
    @staticmethod
    def is_valid_url(url: str) -> bool:
        """验证URL是否为支持的视频平台"""
        patterns = [
            VideoProcessor.YOUTUBE_REGEX,
            VideoProcessor.BILIBILI_REGEX,
            VideoProcessor.TIKTOK_REGEX,
        ]
        return any(re.match(pattern, url, re.IGNORECASE) for pattern in patterns)
    
    @staticmethod
    def get_platform(url: str) -> Optional[str]:
        """识别视频平台"""
        if re.match(VideoProcessor.YOUTUBE_REGEX, url, re.IGNORECASE):
            return "youtube"
        elif re.match(VideoProcessor.BILIBILI_REGEX, url, re.IGNORECASE):
            return "bilibili"
        elif re.match(VideoProcessor.TIKTOK_REGEX, url, re.IGNORECASE):
            return "tiktok"
        return None
    
    @staticmethod
    def validate_duration(duration: int, max_duration: int) -> bool:
        """验证视频时长"""
        return 0 < duration <= max_duration
```

### 6.2 bibigpt_service.py

```python
# app/services/bibigpt_service.py
import httpx
from app.config import get_settings
from typing import Dict, Any

settings = get_settings()

class BibiGPTService:
    """BibiGPT API服务"""
    
    BASE_URL = settings.BIBIGPT_API_URL
    API_KEY = settings.BIBIGPT_API_KEY
    TIMEOUT = settings.BIBIGPT_TIMEOUT
    
    @staticmethod
    async def get_subtitle(video_url: str) -> Dict[str, Any]:
        """
        调用BibiGPT API获取视频字幕
        
        Args:
            video_url: 视频URL
            
        Returns:
            字幕数据字典
            
        Raises:
            Exception: API调用失败
        """
        async with httpx.AsyncClient(timeout=BibiGPTService.TIMEOUT) as client:
            try:
                response = await client.get(
                    f"{BibiGPTService.BASE_URL}/getSubtitle",
                    params={
                        "url": video_url,
                        "enabledSpeaker": "true"
                    },
                    headers={
                        "Authorization": f"Bearer {BibiGPTService.API_KEY}"
                    }
                )
                
                response.raise_for_status()
                data = response.json()
                
                if not data.get("success"):
                    raise Exception("Failed to extract subtitle from BibiGPT")
                
                # 提取并格式化数据
                detail = data.get("detail", {})
                return BibiGPTService._format_response(detail)
                
            except httpx.HTTPStatusError as e:
                raise Exception(f"BibiGPT API error: {e.response.status_code}")
            except httpx.TimeoutException:
                raise Exception("BibiGPT API timeout")
            except Exception as e:
                raise Exception(f"BibiGPT API failed: {str(e)}")
    
    @staticmethod
    def _format_response(detail: Dict[str, Any]) -> Dict[str, Any]:
        """格式化BibiGPT响应"""
        return {
            "title": detail.get("title", "Unknown"),
            "duration": detail.get("duration", 0),
            "thumbnail": detail.get("cover"),
            "author": detail.get("author"),
            "subtitles": [
                {
                    "startTime": sub.get("startTime", 0),
                    "endTime": sub.get("end", 0),
                    "text": sub.get("text", "")
                }
                for sub in detail.get("subtitlesArray", [])
            ]
        }

# 单例实例
bibigpt_service = BibiGPTService()
```

### 6.3 deepseek_service.py

```python
# app/services/deepseek_service.py
import httpx
import json
from app.config import get_settings
from typing import Dict, Any, AsyncIterator

settings = get_settings()

class DeepSeekService:
    """DeepSeek API服务"""
    
    BASE_URL = settings.DEEPSEEK_API_URL
    API_KEY = settings.DEEPSEEK_API_KEY
    MODEL = settings.DEEPSEEK_MODEL
    TIMEOUT = settings.DEEPSEEK_TIMEOUT
    TEMPERATURE = settings.DEEPSEEK_TEMPERATURE
    
    @staticmethod
    def build_code_generation_prompt(subtitle_data: Dict[str, Any]) -> str:
        """构建代码生成Prompt"""
        title = subtitle_data.get("title", "Unknown")
        duration = subtitle_data.get("duration", 0)
        subtitles = subtitle_data.get("subtitles", [])
        
        # 格式化字幕，限制长度
        subtitle_lines = []
        for sub in subtitles[:100]:  # 最多100条字幕
            time_str = f"[{sub['startTime']}s]"
            subtitle_lines.append(f"{time_str} {sub['text']}")
        subtitle_text = "\n".join(subtitle_lines)
        
        return f"""你是一个专业的编程教学代码生成助手。根据视频字幕内容生成完整可运行的Python代码。

【视频信息】
标题: {title}
时长: {duration}秒

【完整字幕】
{subtitle_text}

【要求】
1. 生成完整可运行的Python代码
2. 包含所有必要的import语句
3. 添加详细的中文注释解释关键步骤
4. 遵循PEP8代码规范
5. 包含适当的错误处理
6. 代码应该是教学性质的，易于理解
7. 如果视频包含多个示例，请都包含进来

【输出格式】
- 只输出Python代码，不要用markdown代码块包裹
- 从第一行开始就是代码
- 不要添加任何说明文字

请生成代码："""
    
    @staticmethod
    async def generate_code_stream(subtitle_data: Dict[str, Any]) -> AsyncIterator[str]:
        """
        流式生成代码
        
        Args:
            subtitle_data: 字幕数据
            
        Yields:
            代码片段字符串
        """
        prompt = DeepSeekService.build_code_generation_prompt(subtitle_data)
        
        async with httpx.AsyncClient(timeout=DeepSeekService.TIMEOUT) as client:
            async with client.stream(
                "POST",
                f"{DeepSeekService.BASE_URL}/chat/completions",
                headers={
                    "Authorization": f"Bearer {DeepSeekService.API_KEY}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": DeepSeekService.MODEL,
                    "messages": [
                        {
                            "role": "system",
                            "content": "你是专业的Python代码生成助手，擅长根据教学视频生成清晰易懂的代码。"
                        },
                        {
                            "role": "user",
                            "content": prompt
                        }
                    ],
                    "stream": True,
                    "temperature": DeepSeekService.TEMPERATURE,
                    "max_tokens": 4000
                }
            ) as response:
                async for line in response.aiter_lines():
                    if not line.strip():
                        continue
                    
                    if line.startswith("data: "):
                        data = line[6:]
                        
                        if data == "[DONE]":
                            break
                        
                        try:
                            chunk = json.loads(data)
                            content = chunk.get("choices", [{}])[0].get("delta", {}).get("content")
                            
                            if content:
                                yield content
                        except json.JSONDecodeError:
                            continue

# 单例实例
deepseek_service = DeepSeekService()
```

### 6.4 timeline_service.py

```python
# app/services/timeline_service.py
import httpx
import json
from app.config import get_settings
from typing import Dict, Any

settings = get_settings()

class TimelineService:
    """时间轴生成服务"""
    
    @staticmethod
    def build_timeline_prompt(subtitle_data: Dict[str, Any], code: str) -> str:
        """构建时间轴映射Prompt"""
        subtitles = subtitle_data.get("subtitles", [])
        
        # 格式化字幕（简化版）
        subtitle_summary = []
        for i, sub in enumerate(subtitles):
            if i % 5 == 0:  # 每5条取1条，避免过长
                subtitle_summary.append({
                    "time": sub["startTime"],
                    "text": sub["text"]
                })
        
        subtitle_text = json.dumps(subtitle_summary, indent=2, ensure_ascii=False)
        
        # 统计代码行数
        code_lines = code.split('\n')
        total_lines = len(code_lines)
        
        return f"""你是视频内容分析专家。请根据视频字幕和生成的代码，创建时间轴映射。

【视频字幕摘要】
{subtitle_text}

【生成的代码】（共{total_lines}行）
```python
{code[:2000]}  # 截取前2000字符
...
```

【任务】
分析字幕内容，将视频时间段映射到代码行号。输出JSON格式：

{{
  "segments": [
    {{
      "startTime": 0,
      "endTime": 30,
      "description": "课程介绍",
      "codeLines": null
    }},
    {{
      "startTime": 30,
      "endTime": 120,
      "description": "导入库和环境准备",
      "codeLines": "1-8"
    }}
  ]
}}

【要求】
1. 每个segment覆盖一个逻辑段落（30-120秒为宜）
2. codeLines格式: "起始行-结束行" 或 null（无代码）
3. description简洁描述（10字以内）
4. segments按时间顺序，不重叠
5. 只输出JSON，无其他文字

请生成时间轴："""
    
    @staticmethod
    async def generate_timeline(subtitle_data: Dict[str, Any], code: str) -> Dict[str, Any]:
        """
        生成时间轴映射
        
        Args:
            subtitle_data: 字幕数据
            code: 生成的代码
            
        Returns:
            时间轴数据
        """
        prompt = TimelineService.build_timeline_prompt(subtitle_data, code)
        
        async with httpx.AsyncClient(timeout=60.0) as client:
            try:
                response = await client.post(
                    f"{settings.DEEPSEEK_API_URL}/chat/completions",
                    headers={
                        "Authorization": f"Bearer {settings.DEEPSEEK_API_KEY}",
                        "Content-Type": "application/json"
                    },
                    json={
                        "model": settings.DEEPSEEK_MODEL,
                        "messages": [
                            {
                                "role": "system",
                                "content": "你是JSON数据生成专家，擅长分析视频内容并生成结构化数据。"
                            },
                            {
                                "role": "user",
                                "content": prompt
                            }
                        ],
                        "temperature": 0.1,
                        "response_format": {"type": "json_object"}
                    }
                )
                
                result = response.json()
                content = result["choices"][0]["message"]["content"]
                timeline = json.loads(content)
                
                return timeline
                
            except Exception as e:
                # 返回默认时间轴
                print(f"Timeline generation error: {e}")
                return TimelineService._get_default_timeline(subtitle_data)
    
    @staticmethod
    def _get_default_timeline(subtitle_data: Dict[str, Any]) -> Dict[str, Any]:
        """生成默认时间轴（降级方案）"""
        duration = subtitle_data.get("duration", 0)
        return {
            "segments": [
                {
                    "startTime": 0,
                    "endTime": duration,
                    "description": "完整视频内容",
                    "codeLines": None
                }
            ]
        }

# 单例实例
timeline_service = TimelineService()
```

## 7. SSE工具

```python
# app/utils/sse.py
import json
from typing import Any, Dict

def sse_event(event_type: str, data: Dict[str, Any]) -> str:
    """
    格式化SSE事件
    
    Args:
        event_type: 事件类型（thought, code, timeline等）
        data: 事件数据
        
    Returns:
        格式化的SSE消息字符串
    """
    json_data = json.dumps(data, ensure_ascii=False)
    return f"event: {event_type}\ndata: {json_data}\n\n"
```

## 8. 错误处理

```python
# app/utils/errors.py
from enum import Enum
from typing import Dict

class ErrorCode(str, Enum):
    """错误码枚举"""
    
    # 客户端错误 (1xxx)
    INVALID_VIDEO_URL = "1001"
    VIDEO_TOO_LONG = "1002"
    UNSUPPORTED_PLATFORM = "1003"
    
    # 外部API错误 (2xxx)
    BIBIGPT_API_ERROR = "2001"
    NO_SUBTITLE = "2002"
    DEEPSEEK_API_ERROR = "2003"
    
    # 服务器错误 (3xxx)
    AI_GENERATION_FAILED = "3001"
    DATABASE_ERROR = "3002"
    CACHE_ERROR = "3003"
    
    # 系统错误 (5xxx)
    INTERNAL_ERROR = "5001"

ERROR_MESSAGES: Dict[ErrorCode, str] = {
    ErrorCode.INVALID_VIDEO_URL: "视频URL不支持，请使用YouTube/Bilibili/TikTok链接",
    ErrorCode.VIDEO_TOO_LONG: "视频时长超过2小时，暂不支持",
    ErrorCode.UNSUPPORTED_PLATFORM: "不支持的视频平台",
    ErrorCode.BIBIGPT_API_ERROR: "字幕提取失败，请稍后重试",
    ErrorCode.NO_SUBTITLE: "该视频没有可用字幕",
    ErrorCode.DEEPSEEK_API_ERROR: "代码生成失败，请重试",
    ErrorCode.AI_GENERATION_FAILED: "AI生成失败",
    ErrorCode.DATABASE_ERROR: "数据库操作失败",
    ErrorCode.CACHE_ERROR: "缓存操作失败",
    ErrorCode.INTERNAL_ERROR: "服务器内部错误",
}

def get_error_message(code: ErrorCode) -> str:
    """获取错误消息"""
    return ERROR_MESSAGES.get(code, "Unknown error")
```

## 9. 启动命令

### 9.1 开发环境

```bash
# 启动后端服务
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

# 或使用Python直接运行
python -m uvicorn app.main:app --reload
```

### 9.2 生产环境

```bash
# 使用Gunicorn + Uvicorn workers
gunicorn app.main:app \
  --workers 4 \
  --worker-class uvicorn.workers.UvicornWorker \
  --bind 0.0.0.0:8000 \
  --timeout 120
```

## 10. 数据库迁移

### 10.1 初始化Alembic

```bash
# 初始化
alembic init alembic

# 修改 alembic.ini
# sqlalchemy.url = postgresql://mora:password@localhost:5432/mora
```

### 10.2 创建迁移

```bash
# 创建迁移脚本
alembic revision --autogenerate -m "create sessions table"

# 执行迁移
alembic upgrade head

# 回滚迁移
alembic downgrade -1
```

## 11. Docker配置

详见 `docs/部署方案.md`

## 12. 测试

### 12.1 运行测试

```bash
# 运行所有测试
pytest

# 运行特定测试
pytest tests/test_api.py

# 查看覆盖率
pytest --cov=app tests/
```

### 12.2 测试示例

```python
# tests/test_api.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_create_session():
    response = client.post(
        "/api/session",
        json={
            "videoUrl": "https://www.youtube.com/watch?v=test",
            "language": "python"
        }
    )
    assert response.status_code == 201
    data = response.json()
    assert "sessionId" in data
```

## 13. 日志配置

```python
# app/main.py 中添加
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)
```

## 14. 性能优化建议

1. **连接池配置**：SQLAlchemy和Redis都配置连接池
2. **异步处理**：使用FastAPI的异步特性
3. **缓存策略**：合理使用Redis缓存
4. **超时设置**：所有外部API调用设置超时
5. **限流保护**：使用slowapi库实现限流

## 15. 监控和日志

生产环境建议集成：
- **Sentry**: 错误追踪
- **Prometheus**: 指标监控
- **ELK Stack**: 日志聚合
